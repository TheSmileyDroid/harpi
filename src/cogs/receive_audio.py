"""M√≥dulo para gravar √°udio dos canais de voz do Discord."""

import asyncio
import discord
from discord.ext import commands
from typing import Any, Optional
import tempfile
import os
import logging

logger = logging.getLogger(__name__)

class ReceiveAudioCog(commands.Cog):
    """Cog respons√°vel pela grava√ß√£o de √°udio dos canais de voz."""

    def __init__(self, bot: commands.Bot) -> None:
        """Inicializa o cog de grava√ß√£o de √°udio.

        Args:
            bot: Bot do Discord ao qual este cog ser√° anexado.
        """
        self.bot = bot
        self.connections: dict[int, discord.VoiceClient] = {}
        self.audio_dir = "audio"
        os.makedirs(self.audio_dir, exist_ok=True)
        self._setup_logger()

    def _setup_logger(self) -> None:
        """Configura o logger para este m√≥dulo."""
        logger.setLevel(logging.INFO)
        if not logger.handlers:
            handler = logging.StreamHandler()
            handler.setFormatter(
                logging.Formatter(
                    "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
                )
            )
            logger.addHandler(handler)

    async def process_audio(self, audio_data: bytes) -> str:
        """Process audio data and return text."""
        # Save audio to temporary WAV file
        with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_wav:
            wavfile.write(temp_wav.name, 16000, audio_data)

        # Convert WAV to text using a different approach (e.g., Whisper)
        # This is a placeholder - you'll need to implement the actual transcription logic
        text = "Transcription not implemented yet"

        return text

    @commands.command(name="record")
    async def record(self, ctx: commands.Context) -> None:
        """Inicia a grava√ß√£o de √°udio do canal de voz.

        Args:
            ctx: Contexto do comando.
        """
        # Verifica se o autor do comando est√° em um canal de voz
        if not ctx.author.voice:
            await ctx.send("Voc√™ n√£o est√° em um canal de voz!")
            return

        # Verifica se j√° existe uma grava√ß√£o em andamento no servidor
        if ctx.guild.id in self.connections:
            await ctx.send(
                "J√° existe uma grava√ß√£o em andamento neste servidor!"
            )
            return

        try:
            # Conecta ao canal de voz do autor
            vc = await ctx.author.voice.channel.connect()
            self.connections[ctx.guild.id] = vc

            # Inicia a grava√ß√£o
            vc.start_recording(
                discord.sinks.WaveSink(),
                self.once_done,
                ctx.channel,
                sync_start=True,
            )
            await ctx.send("Grava√ß√£o iniciada!")
            logger.info(f"Grava√ß√£o iniciada no servidor {ctx.guild.id}")
        except Exception as e:
            logger.error(f"Erro ao iniciar grava√ß√£o: {e}")
            await ctx.send(f"Erro ao iniciar grava√ß√£o: {e}")

    @commands.command(name="stop_recording")
    async def stop_recording(self, ctx: commands.Context) -> None:
        """Para a grava√ß√£o de √°udio em andamento.

        Args:
            ctx: Contexto do comando.
        """
        guild_id = getattr(ctx.guild, "id", None)
        if not guild_id:
            await ctx.send("Este comando s√≥ pode ser usado em servidores.")
            return

        if guild_id in self.connections:
            try:
                vc = self.connections[guild_id]
                vc.stop_recording()  # Isso chamar√° o callback once_done
                logger.info(f"Grava√ß√£o finalizada no servidor {guild_id}")
                await ctx.send("Grava√ß√£o finalizada!")
            except Exception as e:
                logger.error(f"Erro ao parar grava√ß√£o: {e}")
                await ctx.send(f"Erro ao parar grava√ß√£o: {e}")
        else:
            await ctx.send("N√£o h√° grava√ß√£o em andamento neste servidor.")

    async def once_done(
        self, sink: discord.sinks.WaveSink, channel: discord.TextChannel, *args: Any
    ) -> None:
        """Callback chamado quando a grava√ß√£o √© finalizada.

        Args:
            sink: Sink contendo os dados de √°udio gravados.
            channel: Canal de texto onde a mensagem ser√° enviada.
            args: Argumentos adicionais.
        """
        assert isinstance(sink, discord.sinks.WaveSink), "O sink deve ser do tipo WaveSink"
        assert isinstance(channel, discord.TextChannel), (
            "O canal deve ser do tipo TextChannel"
        )
        # Obt√©m o ID do servidor a partir da conex√£o de voz
        guild_id: Optional[int] = None
        for gid, vc in self.connections.items():
            if vc == sink.vc:
                guild_id = gid
                break

        if guild_id is not None:
            del self.connections[guild_id]

        # Desconecta do canal de voz
        await sink.vc.disconnect()

        # Prepara os arquivos de √°udio e os usu√°rios gravados
        if not sink.audio_data:
            await channel.send("Nenhum √°udio foi gravado.")
            return

        recorded_users = [
            f"<@{user_id}>" for user_id in sink.audio_data.keys()
        ]

        # Iniciar mensagem de status
        status_message = await channel.send(
            f"üîÑ Processando √°udio de {len(sink.audio_data)} usu√°rios..."
        )

        # Cria arquivos para envio
        files = []
        for user_id, audio in sink.audio_data.items():
            assert isinstance(audio, discord.sinks.AudioData), (
                "O objeto de √°udio deve ser do tipo AudioData"
            )
            assert isinstance(audio.file, io.BytesIO), (
                "O arquivo de √°udio deve ser do tipo BytesIO"
            )

            # Faz uma c√≥pia do arquivo para transcri√ß√£o, j√° que vamos usar a posi√ß√£o original para envio
            current_pos = audio.file.tell()
            audio.file.seek(0)
            audio_copy = io.BytesIO(audio.file.read())
            audio.file.seek(current_pos)

            # Prepara o arquivo para envio
            files.append(discord.File(audio.file, f"{user_id}.wav"))

        # Envia os arquivos de √°udio
        try:
            await channel.send(
                f"Grava√ß√£o finalizada para: {', '.join(recorded_users)}.",
                files=files,
            )

            # Atualiza mensagem de status
            await status_message.edit(
                content="üìÑ Arquivos de √°udio enviados! Iniciando transcri√ß√£o em tempo real..."
            )

            # Inicia transcri√ß√µes em tempo real para cada arquivo
            transcription_tasks = []
            for user_id, audio in sink.audio_data.items():
                # Cria uma c√≥pia do arquivo para transcri√ß√£o
                audio_copy = io.BytesIO()
                audio.file.seek(0)
                audio_copy.write(audio.file.read())
                audio_copy.seek(0)

                # Adiciona a tarefa de transcri√ß√£o √† lista
                task = asyncio.create_task(
                    self.process_audio(audio_copy.read())
                )
                transcription_tasks.append(task)

            # Aguarda todas as transcri√ß√µes terminarem
            await asyncio.gather(*transcription_tasks)

            # Atualiza a mensagem de status para conclu√≠do
            await status_message.edit(
                content="‚úÖ Processamento de √°udio conclu√≠do!"
            )

            logger.info(
                f"Arquivos de √°udio e transcri√ß√µes enviados para o canal {channel.id}"
            )
        except Exception as e:
            logger.error(f"Erro ao processar √°udio: {e}")
            await status_message.edit(
                content=f"‚ùå Erro ao processar √°udio: {e}"
            )


if __name__ == "__main__":
    """Testa a funcionalidade de transcri√ß√£o com um arquivo de √°udio existente."""
    import argparse
    import asyncio
    import pathlib

    # Configura o parser de argumentos para permitir testar com diferentes arquivos
    parser = argparse.ArgumentParser(
        description="Testa a transcri√ß√£o de √°udio"
    )
    parser.add_argument(
        "--arquivo",
        type=str,
        default=".voice_recordings/439894995890208768.wav",
        help="Caminho para o arquivo de √°udio a ser transcrito",
    )

    args = parser.parse_args()

    # Configura o logger para exibir mensagens durante o teste
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # Define uma fun√ß√£o para testar a transcri√ß√£o
    async def test_transcription(
        audio_path: str,
    ) -> None:
        """Testa a transcri√ß√£o de um arquivo de √°udio.

        Args:
            audio_path: Caminho para o arquivo de √°udio.
        """
        # Verifica se o arquivo existe
        audio_file_path = pathlib.Path(audio_path)
        if not audio_file_path.exists():
            print(f"‚ùå Erro: O arquivo {audio_path} n√£o existe.")
            return

        print(f"üéØ Testando transcri√ß√£o do arquivo: {audio_path}")

        try:
            # Abre o arquivo como BytesIO para simular o processamento real
            with open(audio_file_path, "rb") as f:
                audio_data = io.BytesIO(f.read())

            # Processa o √°udio
            text = await ReceiveAudioCog(None).process_audio(audio_data.read())

            # Exibe a transcri√ß√£o completa
            print("\nüìù Transcri√ß√£o completa:")
            print(f'"{text}"')

            # Se n√£o houver transcri√ß√£o, exibe uma mensagem
            if not text:
                print("‚ùó Nenhum texto foi reconhecido no √°udio.")

        except Exception as e:
            print(f"‚ùå Erro durante a transcri√ß√£o: {str(e)}")
            import traceback

            traceback.print_exc()

    # Executa o teste
    try:
        asyncio.run(
            test_transcription(args.arquivo)
        )
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Teste interrompido pelo usu√°rio.")
    except Exception as e:
        print(f"‚ùå Erro inesperado: {str(e)}")
        import traceback

        traceback.print_exc()
